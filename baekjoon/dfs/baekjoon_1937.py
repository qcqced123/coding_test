import sys
"""
[풀이 시간]
15:50 ~ 16:20

[문제 정리]
- 테이블 크기: nxn 사이즈, 
- 이동 방향: 상,하,좌,우
- 이동 규칙: 이동 하려는 지역이 현재 지역보다 대나무가 더 많아야 함
- 목적: 최대로 이동하게 만드는 경로 찾기

[전략]
- 테이블 크기가 500이라서 O(N^2)까지 가능할 것 같음
- 지금 시작 위치도 지정해줘야 하는데, 다음 시점에 이동할 방향은 현재 시점의 대나무 개수보다 적으면 갈 수 없음
- 전체 테이블 중에서 최소값을 시작 위치로 잡는 것이 가장 좋지 않을까?? => 테이블 정보를 입력 받으면서 최소값을 업데이트 하는 방식이 제일 좋아보임  
- 시작하는 지점도 그냥 카운트 해주는 듯, 전체 테이블 중에서 최소값에서 시작하는게 최대값을 보장하지 못함.

** 3109번 리뷰 하고 여기로 다시 돌아오자, 같은 아이디어를 사용하는 문제인 것 같다
** 가장 그리디한 DFS 알고리즘을 어떻게 적용할 수 있지?? 
"""
n, min_value, forest = int(sys.stdin.readline()), 0, []
for i in range(n):
    row = list(map(int, sys.stdin.readline().split()))
    if min_value > min(row):
        min_value = row
        src = [i, row.index(min_value)]
    forest.append(row)
